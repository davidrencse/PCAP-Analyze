# Session model
"""
Session models for Asphalt.

A session represents a logical grouping of packets (capture session).
SessionManifest is the authoritative metadata source.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from datetime import datetime
import json
from pathlib import Path

@dataclass
class SessionManifest:
    """
    Authoritative metadata for a capture session.
    
    This manifest:
    1. Identifies the session uniquely (session_id)
    2. Describes the source and scope
    3. Contains statistical summaries
    4. Maps to physical storage
    
    The manifest is saved as JSON and used to "reopen" sessions.
    """
    
    # ========== CORE IDENTIFICATION ==========
    session_id: str
    """Deterministic hash of (source_hash + time_range + packet_count).
    Generated by SessionManifestBuilder."""
    
    created_at: str  # ISO 8601 timestamp
    """When this manifest was created (UTC)."""
    
    
    # ========== SOURCE INFORMATION ==========
    source_type: str  # "file", "interface", "upload"
    """How packets were acquired."""
    
    source_hash: str  # SHA256 of source file
    """Hash of original data source for integrity verification."""
    
    
    # ========== TEMPORAL SCOPE ==========
    time_start_us: int  # First packet timestamp
    """Earliest packet time in microseconds."""
    
    time_end_us: int  # Last packet timestamp
    """Latest packet time in microseconds."""
    
    
    # ========== PACKET STATISTICS ==========
    total_packets: int
    """Total packets in session."""
    
    total_bytes_captured: int
    """Sum of captured_length for all packets."""
    
    total_bytes_original: int
    """Sum of original_length for all packets."""
    
    
    # ========== STORAGE MAPPING ==========
    file_mapping: Dict[str, str] = field(default_factory=dict)
    """Mapping from file_id to file path.
    Example: {"0": "/data/capture_1.pcap", "1": "/data/capture_2.pcap"}"""
    
    
    # ========== SCHEMA VERSIONS ==========
    index_schema_version: str = "0.2.0"
    """Version of PacketIndexRecord schema used."""
    
    manifest_schema_version: str = "0.2.0"
    """Version of this manifest schema."""
    
    
    # ========== OPTIONAL FIELDS ==========
    original_path: Optional[str] = None
    """Original file path (optional for privacy/portability)."""
    
    
    # ========== CAPTURE METADATA ==========
    capture_filter: Optional[str] = None
    """BPF filter applied during capture (if any)."""
    
    interface_name: Optional[str] = None
    """Network interface name (for live captures)."""
    
    link_types: List[int] = field(default_factory=list)
    """List of DLT_* link types present in session."""
    
    snaplen: Optional[int] = None
    """Maximum captured packet length (if limited)."""
    
    # ========== SERIALIZATION ==========
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with deterministic field ordering."""
        result = {
            'session_id': self.session_id,
            'created_at': self.created_at,
            'source_type': self.source_type,
            'source_hash': self.source_hash,
            'time_start_us': self.time_start_us,
            'time_end_us': self.time_end_us,
            'total_packets': self.total_packets,
            'total_bytes_captured': self.total_bytes_captured,
            'total_bytes_original': self.total_bytes_original,
            'file_mapping': self.file_mapping,
            'index_schema_version': self.index_schema_version,
            'manifest_schema_version': self.manifest_schema_version,
        }
        
        # Add optional fields only if they have values
        if self.original_path:
            result['original_path'] = self.original_path
        if self.capture_filter:
            result['capture_filter'] = self.capture_filter
        if self.interface_name:
            result['interface_name'] = self.interface_name
        if self.link_types:
            result['link_types'] = self.link_types
        if self.snaplen:
            result['snaplen'] = self.snaplen
            
        return result
    
    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent)
    
    def save(self, filepath: str):
        """
        Save manifest to file.
        
        Creates parent directories if they don't exist.
        """
        path = Path(filepath)
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w') as f:
            f.write(self.to_json())
    
    @classmethod
    def load(cls, filepath: str) -> 'SessionManifest':
        """Load manifest from file."""
        with open(filepath, 'r') as f:
            data = json.load(f)
        return cls.from_dict(data)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SessionManifest':
        """Create manifest from dictionary with backward compatibility."""
        # Handle missing fields in older versions
        defaults = {
            'original_path': None,
            'capture_filter': None,
            'interface_name': None,
            'link_types': [],
            'snaplen': None,
            'index_schema_version': '0.2.0',
            'manifest_schema_version': '0.2.0',
        }
        
        # Merge defaults with provided data
        merged = {**defaults, **data}
        
        return cls(**merged)
    
    # ========== HELPER METHODS ==========
    
    @property
    def duration_seconds(self) -> float:
        """Session duration in seconds."""
        if self.time_end_us > self.time_start_us:
            return (self.time_end_us - self.time_start_us) / 1_000_000.0
        return 0.0
    
    @property
    def avg_packet_size(self) -> float:
        """Average captured packet size in bytes."""
        if self.total_packets > 0:
            return self.total_bytes_captured / self.total_packets
        return 0.0
    
    @property
    def avg_bitrate(self) -> float:
        """Average bitrate in bits per second."""
        duration = self.duration_seconds
        if duration > 0:
            return (self.total_bytes_captured * 8) / duration
        return 0.0
    
    def get_file_path(self, file_id: str) -> Optional[str]:
        """Get file path for given file_id."""
        return self.file_mapping.get(file_id)
    
    def validate(self) -> List[str]:
        """
        Validate manifest consistency.
        
        Returns list of warning/error messages.
        """
        issues = []
        
        if self.total_packets < 0:
            issues.append("total_packets cannot be negative")
        
        if self.time_end_us < self.time_start_us:
            issues.append("time_end_us is before time_start_us")
        
        if not self.session_id:
            issues.append("session_id is empty")
        
        if not self.source_hash:
            issues.append("source_hash is empty")
        
        # Check for placeholder values
        if self.src_ip == "0.0.0.0" and self.total_packets > 0:
            issues.append("IP addresses not decoded (expected for Sprint 0.2)")
            
        return issues
